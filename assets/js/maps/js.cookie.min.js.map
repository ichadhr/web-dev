{"version":3,"sources":["js.cookie.js"],"names":["factory","jQuery","define","amd","exports","require","e","module","window","Cookies","$","encode","s","api","raw","encodeURIComponent","decode","decodeURIComponent","stringifyCookieValue","value","json","JSON","stringify","String","parseCookieValue","indexOf","slice","replace","pluses","parse","read","converter","isFunction","extend","key","options","i","result","arguments","length","obj","Object","prototype","toString","call","defaults","expires","days","t","Date","setMilliseconds","getMilliseconds","document","cookie","toUTCString","path","domain","secure","join","undefined","cookies","split","l","parts","name","shift","get","set","remove","removeCookie"],"mappings":"CAOC,SAAUA,GACV,GAAIC,EACJ,IAAsB,kBAAXC,SAAyBA,OAAOC,IAE1CD,QAAQ,UAAWF,OACb,IAAuB,gBAAZI,SAAsB,CAEvC,IACCH,EAASI,QAAQ,UAChB,MAAMC,IACRC,OAAOH,QAAUJ,EAAQC,OAGzBO,QAAOC,QAAUT,EAAQQ,OAAOP,SAEhC,SAAUS,GAIX,QAASC,GAAOC,GACf,MAAOC,GAAIC,IAAMF,EAAIG,mBAAmBH,GAGzC,QAASI,GAAOJ,GACf,MAAOC,GAAIC,IAAMF,EAAIK,mBAAmBL,GAGzC,QAASM,GAAqBC,GAC7B,MAAOR,GAAOE,EAAIO,KAAOC,KAAKC,UAAUH,GAASI,OAAOJ,IAGzD,QAASK,GAAiBZ,GACF,IAAnBA,EAAEa,QAAQ,OAEbb,EAAIA,EAAEc,MAAM,GAAI,GAAGC,QAAQ,OAAQ,KAAKA,QAAQ,QAAS,MAG1D,KAKC,MADAf,GAAIK,mBAAmBL,EAAEe,QAAQC,EAAQ,MAClCf,EAAIO,KAAOC,KAAKQ,MAAMjB,GAAKA,EACjC,MAAMN,KAGT,QAASwB,GAAKlB,EAAGmB,GAChB,GAAIZ,GAAQN,EAAIC,IAAMF,EAAIY,EAAiBZ,EAC3C,OAAOoB,GAAWD,GAAaA,EAAUZ,GAASA,EAGnD,QAASc,KAIR,IAHA,GAAIC,GAAKC,EACLC,EAAI,EACJC,KACGD,EAAIE,UAAUC,OAAQH,IAAK,CACjCD,EAAUG,UAAWF,EACrB,KAAKF,IAAOC,GACXE,EAAOH,GAAOC,EAAQD,GAGxB,MAAOG,GAGR,QAASL,GAAWQ,GACnB,MAA+C,sBAAxCC,OAAOC,UAAUC,SAASC,KAAKJ,GAhDvC,GAAIZ,GAAS,MAmDTf,EAAM,SAAUqB,EAAKf,EAAOgB,GAI/B,GAAIG,UAAUC,OAAS,IAAMP,EAAWb,GAAQ,CAG/C,GAFAgB,EAAUF,EAAOpB,EAAIgC,SAAUV,GAEA,gBAApBA,GAAQW,QAAsB,CACxC,GAAIC,GAAOZ,EAAQW,QAASE,EAAIb,EAAQW,QAAU,GAAIG,KACtDD,GAAEE,gBAAgBF,EAAEG,kBAA2B,MAAPJ,GAGzC,MAAQK,UAASC,QAChB1C,EAAOuB,GAAM,IAAKhB,EAAqBC,GACvCgB,EAAQW,QAAU,aAAeX,EAAQW,QAAQQ,cAAgB,GACjEnB,EAAQoB,KAAU,UAAYpB,EAAQoB,KAAO,GAC7CpB,EAAQqB,OAAU,YAAcrB,EAAQqB,OAAS,GACjDrB,EAAQsB,OAAU,WAAa,IAC9BC,KAAK,IAaR,IARA,GAAIrB,GAASH,MAAMyB,MAIlBC,EAAUR,SAASC,OAASD,SAASC,OAAOQ,MAAM,SAClDzB,EAAI,EACJ0B,EAAIF,EAAQrB,OAENH,EAAI0B,EAAG1B,IAAK,CAClB,GAAI2B,GAAQH,EAAQxB,GAAGyB,MAAM,KAC5BG,EAAOhD,EAAO+C,EAAME,SACpBZ,EAASU,EAAML,KAAK,IAErB,IAAIxB,IAAQ8B,EAAM,CAEjB3B,EAASP,EAAKuB,EAAQlC,EACtB,OAIIe,OAAmCyB,MAA3BN,EAASvB,EAAKuB,MAC1BhB,EAAO2B,GAAQX,GAIjB,MAAOhB,GAiBR,OAdAxB,GAAIqD,IAAMrD,EAAIsD,IAAMtD,EACpBA,EAAIgC,YAEJhC,EAAIuD,OAAS,SAAUlC,EAAKC,GAG3B,MADAtB,GAAIqB,EAAK,GAAID,EAAOE,GAAWW,SAAU,MACjCjC,EAAIqB,IAGRxB,IACJA,EAAE2C,OAASxC,EACXH,EAAE2D,aAAexD,EAAIuD,QAGfvD","file":"../js.cookie.min.js","sourcesContent":["/*!\n * Javascript Cookie v1.5.0\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2014 Klaus Hartl\n * Released under the MIT license\n */\n(function (factory) {\n\tvar jQuery;\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD (Register as an anonymous module)\n\t\tdefine(['jquery'], factory);\n\t} else if (typeof exports === 'object') {\n\t\t// Node/CommonJS\n\t\ttry {\n\t\t\tjQuery = require('jquery');\n\t\t} catch(e) {}\n\t\tmodule.exports = factory(jQuery);\n\t} else {\n\t\t// Browser globals\n\t\twindow.Cookies = factory(window.jQuery);\n\t}\n}(function ($) {\n\n\tvar pluses = /\\+/g;\n\n\tfunction encode(s) {\n\t\treturn api.raw ? s : encodeURIComponent(s);\n\t}\n\n\tfunction decode(s) {\n\t\treturn api.raw ? s : decodeURIComponent(s);\n\t}\n\n\tfunction stringifyCookieValue(value) {\n\t\treturn encode(api.json ? JSON.stringify(value) : String(value));\n\t}\n\n\tfunction parseCookieValue(s) {\n\t\tif (s.indexOf('\"') === 0) {\n\t\t\t// This is a quoted cookie as according to RFC2068, unescape...\n\t\t\ts = s.slice(1, -1).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n\t\t}\n\n\t\ttry {\n\t\t\t// Replace server-side written pluses with spaces.\n\t\t\t// If we can't decode the cookie, ignore it, it's unusable.\n\t\t\t// If we can't parse the cookie, ignore it, it's unusable.\n\t\t\ts = decodeURIComponent(s.replace(pluses, ' '));\n\t\t\treturn api.json ? JSON.parse(s) : s;\n\t\t} catch(e) {}\n\t}\n\n\tfunction read(s, converter) {\n\t\tvar value = api.raw ? s : parseCookieValue(s);\n\t\treturn isFunction(converter) ? converter(value) : value;\n\t}\n\n\tfunction extend() {\n\t\tvar key, options;\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\toptions = arguments[ i ];\n\t\t\tfor (key in options) {\n\t\t\t\tresult[key] = options[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction isFunction(obj) {\n\t\treturn Object.prototype.toString.call(obj) === '[object Function]';\n\t}\n\n\tvar api = function (key, value, options) {\n\n\t\t// Write\n\n\t\tif (arguments.length > 1 && !isFunction(value)) {\n\t\t\toptions = extend(api.defaults, options);\n\n\t\t\tif (typeof options.expires === 'number') {\n\t\t\t\tvar days = options.expires, t = options.expires = new Date();\n\t\t\t\tt.setMilliseconds(t.getMilliseconds() + days * 864e+5);\n\t\t\t}\n\n\t\t\treturn (document.cookie = [\n\t\t\t\tencode(key), '=', stringifyCookieValue(value),\n\t\t\t\toptions.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n\t\t\t\toptions.path    ? '; path=' + options.path : '',\n\t\t\t\toptions.domain  ? '; domain=' + options.domain : '',\n\t\t\t\toptions.secure  ? '; secure' : ''\n\t\t\t].join(''));\n\t\t}\n\n\t\t// Read\n\n\t\tvar result = key ? undefined : {},\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t\t// calling \"get()\".\n\t\t\tcookies = document.cookie ? document.cookie.split('; ') : [],\n\t\t\ti = 0,\n\t\t\tl = cookies.length;\n\n\t\tfor (; i < l; i++) {\n\t\t\tvar parts = cookies[i].split('='),\n\t\t\t\tname = decode(parts.shift()),\n\t\t\t\tcookie = parts.join('=');\n\n\t\t\tif (key === name) {\n\t\t\t\t// If second argument (value) is a function it's a converter...\n\t\t\t\tresult = read(cookie, value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Prevent storing a cookie that we couldn't decode.\n\t\t\tif (!key && (cookie = read(cookie)) !== undefined) {\n\t\t\t\tresult[name] = cookie;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tapi.get = api.set = api;\n\tapi.defaults = {};\n\n\tapi.remove = function (key, options) {\n\t\t// Must not alter options, thus extending a fresh object...\n\t\tapi(key, '', extend(options, { expires: -1 }));\n\t\treturn !api(key);\n\t};\n\n\tif ( $ ) {\n\t\t$.cookie = api;\n\t\t$.removeCookie = api.remove;\n\t}\n\n\treturn api;\n}));\n"]}